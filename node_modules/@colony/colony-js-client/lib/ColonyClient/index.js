'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _colonyJsContractClient = require('@colony/colony-js-contract-client');

var _colonyJsContractClient2 = _interopRequireDefault(_colonyJsContractClient);

var _colonyJsUtils = require('@colony/colony-js-utils');

var _index = require('../ColonyNetworkClient/index');

var _index2 = _interopRequireDefault(_index);

var _index3 = require('../TokenClient/index');

var _index4 = _interopRequireDefault(_index3);

var _index5 = require('../AuthorityClient/index');

var _index6 = _interopRequireDefault(_index5);

var _GetTask = require('./callers/GetTask');

var _GetTask2 = _interopRequireDefault(_GetTask);

var _constants = require('../constants');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ColonyClient = function (_ContractClient) {
  (0, _inherits3.default)(ColonyClient, _ContractClient);
  (0, _createClass3.default)(ColonyClient, null, [{
    key: 'defaultQuery',

    /*
      Waive reward payout. This unlocks the sender's tokens and increments the users reward payout counter, allowing them to claim the next reward payout.
    */

    /*
      In the case of the Colony Network, only the Meta Colony may mint new tokens.
    */

    /*
      Move a given amount of `token` funds from one pot to another.
    */

    /*
      Move any funds received by the colony in `source` denomination to the top-levl domain pot, siphoning off a small amount to the rewards pot. No fee is taken if called against a colony's own token.
    */

    /*
      Adds a domain to the Colony along with the new domain's respective local skill. This can only be called by owners of the colony.
    */

    /*
      Finalizes a task, allowing roles to claim payouts and prohibiting all further changes to the task.
    */

    /*
      In the event of a user not committing or revealing within the 10 day rating window, their rating of their counterpart is assumed to be the highest possible and their own rating is decreased by 5 (e.g. 0.5 points). This function may be called by anyone after the taskWorkRatings period has ended.
    */

    /*
      Submits a hidden work rating for a task. This is generated by generateSecret(_salt, _rating).
    */

    /*
      Sets the payout given to the WORKER role when the task is finalized.
    */

    /*
      Sets the payout given to the EVALUATOR role when the task is finalized.
    */

    /*
      Set the user for role `_role` in task `_id`. Only allowed before the task is `finalized`, meaning that the value cannot be changed after the task is complete. This can only be called by the manager of the task.
    */

    /*
      Every task must belong to a single existing Domain. This can only be called by the manager of the task.
    */

    /*
      Creates a new task by invoking `makeTask` on-chain.
    */

    /*
      Gets the address of the colony's official token contract.
    */

    /*
      The `nonRewardPotsTotal` is a value that keeps track of the total assets a colony has to work with, which may be split among several distinct pots associated with various domains and tasks.
    */

    /*
      If ratings for a task are still in the commit period, their ratings will still be hidden, but the hashed value can still be returned.
    */

    /*
      Every task has three roles associated with it which determine permissions for editing the task, submitting work, and ratings for performance.
    */

    /*
      Gets a certain task defined by its integer taskId.
    */

    /*
      Gets the number of claimed and waived reward payouts for a given user.
    */

    /*
      Gets the total number of domains in a Colony. This number equals the last `domainId` created.
    */

    /*
      Helper function used to generate the rating secret used in task ratings. Accepts a salt value and a value to hide, and returns the keccak256 hash of both.
    */
    get: function get() {
      return {
        contractName: 'IColony'
      };
    }
    /*
      Start the next reward payout for `token`. All funds in the reward pot for `token` will become unavailable. All tokens will be locked, and can be unlocked by calling `waiveRewardPayout` or `claimRewardPayout`.
    */

    /*
      The owner of a Colony may mint new tokens.
    */

    /*
      Finalises the reward payout and allows creation of next reward payout for token that has been used in `payoutId`. Can only be called when reward payout cycle is finished, i.e. 60 days from its creation.
    */

    /*
      Adds a global skill under a given parent SkillId. This can only be called from the Meta Colony, and only by the Meta Colony owners.
    */

    /*
      Claims the payout in `source` denomination for work completed in task `taskId` by contributor with role `role`. Allowed only by the contributors themselves after task is finalized. Here the network receives its fee from each payout. Ether fees go straight to the Meta Colony whereas Token fees go to the Network to be auctioned off.
    */

    /*
      Cancels a task.
    */

    /*
      Reveals a previously submitted work rating, by proving that the `_rating` and `_salt` values result in the same `ratingSecret` submitted during the rating submission period. This is checked on-chain using the `generateSecret` function.
    */

    /*
      Submit the task deliverable, i.e. the output of the work performed for task `_id` Submission is allowed only to the assigned worker before the task due date. Submissions cannot be overwritten.
    */

    /*
      Sets the payout given to the MANAGER role when the task is finalized. This Sender can only be called by the manager for the task in question.
    */

    /*
    Sets the skill tag associated with the task. Currently there is only one skill tag available per task, but additional skills for tasks are planned in future implementations. This can only be called by the manager of the task.
    */

    /*
      The task's due date determines when a worker may submit the task's deliverable(s).
    */

    /*
      The task brief, or specification, is a description of the tasks work specification. The description is hashed and stored with the task for future reference in ratings or in the event of a dispute.
    */

    /*
      Returns the total number of transactions the colony has made, == the `transactionId` of the last added transaction to the Colony.
    */

    /*
      Given a specific payout, returns useful information about the payout.
    */

    /*
      Gets a balance for a certain source in a specific pot.
    */

    /*
      For a given task, will return the number of submitted ratings and the date of their submission.
    */

    /*
      Given a specific task, a defined role for the task, and a token address, will return any payout attached to the task in the token specified.
    */

    /*
      Gets the total number of tasks in a Colony. This number equals the last `taskId` created.
    */

    /*
      Gets the total number of reward payout cycles.
    */

    /*
      Gets the selected domain's local skill ID and funding pot ID.
    */


    /*
      Gets the colony's Authority contract address
    */

  }]);

  function ColonyClient(_ref) {
    var _ret;

    var adapter = _ref.adapter,
        authority = _ref.authority,
        networkClient = _ref.networkClient,
        query = _ref.query,
        token = _ref.token;
    (0, _classCallCheck3.default)(this, ColonyClient);

    var _this = (0, _possibleConstructorReturn3.default)(this, (ColonyClient.__proto__ || Object.getPrototypeOf(ColonyClient)).call(this, { adapter: adapter, query: query }));

    if (!(networkClient instanceof _index2.default)) throw new Error('A `networkClient` property must be supplied ' + '(an instance of `ColonyNetworkClient`)');

    _this.networkClient = networkClient;
    if (token) _this.token = token;
    if (authority) _this.authority = authority;

    return _ret = _this, (0, _possibleConstructorReturn3.default)(_this, _ret);
  }

  (0, _createClass3.default)(ColonyClient, [{
    key: 'init',
    value: function () {
      var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
        var _ref3, tokenAddress, _ref4, authorityAddress;

        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return (0, _get3.default)(ColonyClient.prototype.__proto__ || Object.getPrototypeOf(ColonyClient.prototype), 'init', this).call(this);

              case 2:
                _context.next = 4;
                return this.getToken.call();

              case 4:
                _ref3 = _context.sent;
                tokenAddress = _ref3.address;

                if (this.token instanceof _index4.default) {
                  _context.next = 10;
                  break;
                }

                this.token = new _index4.default({
                  adapter: this.adapter,
                  query: { contractAddress: tokenAddress }
                });
                _context.next = 10;
                return this.token.init();

              case 10:
                _context.next = 12;
                return this.getAuthority.call();

              case 12:
                _ref4 = _context.sent;
                authorityAddress = _ref4.address;

                if (this.authority instanceof _index6.default) {
                  _context.next = 18;
                  break;
                }

                this.authority = new _index6.default({
                  adapter: this.adapter,
                  query: { contractAddress: authorityAddress }
                });
                _context.next = 18;
                return this.authority.init();

              case 18:
                return _context.abrupt('return', this);

              case 19:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function init() {
        return _ref2.apply(this, arguments);
      }

      return init;
    }()
  }, {
    key: 'initializeContractMethods',
    value: function initializeContractMethods() {
      var _this2 = this;

      this.getTask = new _GetTask2.default({ client: this });

      var makeTaskCaller = function makeTaskCaller(name, input, output) {
        return _this2.addCaller(name, {
          input: [['taskId', 'number']].concat((0, _toConsumableArray3.default)(input)),
          output: output,
          validateEmpty: function () {
            var _ref6 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(_ref5) {
              var taskId = _ref5.taskId;

              var _ref7, count;

              return _regenerator2.default.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      _context2.next = 2;
                      return _this2.getTaskCount.call();

                    case 2:
                      _ref7 = _context2.sent;
                      count = _ref7.count;

                      (0, _assert2.default)(taskId <= count, 'Task with ID ' + taskId + ' not found');
                      return _context2.abrupt('return', true);

                    case 6:
                    case 'end':
                      return _context2.stop();
                  }
                }
              }, _callee2, _this2);
            }));

            function validateEmpty(_x) {
              return _ref6.apply(this, arguments);
            }

            return validateEmpty;
          }()
        });
      };

      makeTaskCaller('getTaskPayout', [['role', 'role'], ['source', 'payableAddress']], [['amount', 'bigNumber']]);
      makeTaskCaller('getTaskRole', [['role', 'role']], [['address', 'address'], ['rated', 'boolean'], ['rating', 'number']]);
      makeTaskCaller('getTaskWorkRatings', [], [['count', 'number'], ['date', 'date']]);
      makeTaskCaller('getTaskWorkRatingSecret', [['role', 'role']], [['secret', 'string']]);

      // Callers
      this.addCaller('getAuthority', {
        functionName: 'authority',
        output: [['address', 'address']]
      });
      this.addCaller('generateSecret', {
        input: [['salt', 'string'], ['value', 'bigNumber']],
        output: [['secret', 'string']]
      });
      this.addCaller('getDomain', {
        input: [['domainId', 'number']],
        output: [['localSkillId', 'number'], ['potId', 'number']],
        validateEmpty: function () {
          var _ref9 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(_ref8) {
            var domainId = _ref8.domainId;

            var _ref10, count;

            return _regenerator2.default.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.next = 2;
                    return _this2.getDomainCount.call();

                  case 2:
                    _ref10 = _context3.sent;
                    count = _ref10.count;

                    if (!(domainId > count)) {
                      _context3.next = 6;
                      break;
                    }

                    throw new Error('Domain ID ' + domainId + ' not found');

                  case 6:
                    return _context3.abrupt('return', true);

                  case 7:
                  case 'end':
                    return _context3.stop();
                }
              }
            }, _callee3, _this2);
          }));

          function validateEmpty(_x2) {
            return _ref9.apply(this, arguments);
          }

          return validateEmpty;
        }()
      });
      this.addCaller('getDomainCount', {
        output: [['count', 'number']]
      });
      this.addCaller('getGlobalRewardPayoutCount', {
        output: [['count', 'number']]
      });
      this.addCaller('getUserRewardPayoutCount', {
        input: [['user', 'address']],
        output: [['count', 'number']]
      });
      this.addCaller('getNonRewardPotsTotal', {
        input: [['source', 'payableAddress']],
        output: [['total', 'bigNumber']]
      });
      this.addCaller('getPotBalance', {
        input: [['potId', 'number'], ['source', 'payableAddress']],
        output: [['balance', 'bigNumber']]
      });
      this.addCaller('getRewardPayoutInfo', {
        input: [['payoutId'], 'number'],
        output: [['reputationRootHash', 'string'], ['totalTokens', 'bigNumber'], ['totalTokenAmountForRewardPayout', 'bigNumber'], ['remainingTokenAmount', 'bigNumber'], ['source', 'payableAddress'], ['blockNumber', 'number']]
      });
      this.addCaller('getTaskCount', {
        output: [['count', 'number']]
      });
      this.addCaller('getToken', {
        output: [['address', 'address']]
      });

      // Events
      this.addEvent('TaskAdded', [['id', 'number']]);
      this.addEvent('TaskBriefChanged', [['id', 'number'], ['specificationHash', 'ipfsHash']]);
      this.addEvent('TaskDueDateChanged', [['id', 'number'], ['dueDate', 'number']]);
      this.addEvent('TaskDomainChanged', [['id', 'number'], ['domainId', 'number']]);
      this.addEvent('TaskSkillChanged', [['id', 'number'], ['skillId', 'number']]);
      this.addEvent('TaskRoleUserChanged', [['id', 'number'], ['role', 'number'], ['user', 'address']]);
      this.addEvent('TaskWorkerPayoutChanged', [['id', 'number'], ['token', 'address'], ['amount', 'number']]);
      this.addEvent('TaskFinalized', [['id', 'number']]);
      this.addEvent('TaskCanceled', [['id', 'number']]);

      // Senders
      var SkillAdded = {
        contract: this.networkClient.contract,
        handler: function handler(_ref11) {
          var parentSkillId = _ref11.parentSkillId,
              skillId = _ref11.skillId;

          return {
            parentSkillId: parentSkillId.toNumber(),
            skillId: skillId.toNumber()
          };
        }
      };
      this.addSender('addDomain', {
        input: [['parentSkillId', 'number']],
        eventHandlers: {
          SkillAdded: SkillAdded
        }
      });
      this.addSender('addGlobalSkill', {
        input: [['parentSkillId', 'number']],
        eventHandlers: {
          SkillAdded: SkillAdded
        }
      });
      this.addSender('assignWorkRating', {
        input: [['taskId', 'number']]
      });
      this.addSender('cancelTask', {
        input: [['taskId', 'number']]
      });
      this.addSender('claimColonyFunds', {
        input: [['source', 'payableAddress']]
      });
      this.addSender('claimPayout', {
        input: [['taskId', 'number'], ['role', 'role'], ['source', 'payableAddress']]
      });
      this.addSender('createTask', {
        functionName: 'makeTask',
        input: [['specificationHash', 'ipfsHash'], ['domainId', 'number', _constants.DEFAULT_DOMAIN_ID]],
        eventHandlers: {
          TaskAdded: {
            contract: this.contract,
            handler: function handler(_ref12) {
              var id = _ref12.id;

              return {
                taskId: id.toNumber()
              };
            }
          }
        }
      });
      this.addSender('finalizeTask', {
        input: [['taskId', 'number']]
      });
      this.addSender('finalizeRewardPayout', {
        input: [['payoutId', 'number']]
      });
      this.addSender('mintTokens', {
        input: [['amount', 'bigNumber']]
      });
      this.addSender('mintTokensForColonyNetwork', {
        input: [['amount', 'bigNumber']]
      });
      this.addSender('moveFundsBetweenPots', {
        input: [['fromPot', 'number'], ['toPot', 'number'], ['amount', 'bigNumber'], ['address', 'address']]
      });
      this.addSender('revealTaskWorkRating', {
        input: [['taskId', 'number'], ['role', 'role'], ['rating', 'number'], ['salt', 'string']]
      });
      this.addSender('setTaskDomain', {
        input: [['taskId', 'number'], ['domainId', 'number']]
      });
      this.addSender('setTaskRoleUser', {
        input: [['taskId', 'number'], ['role', 'role'], ['user', 'address']]
      });
      this.addSender('setTaskManagerPayout', {
        input: [['taskId', 'number'], ['source', 'payableAddress'], ['amount', 'bigNumber']]
      });
      this.addSender('setTaskSkill', {
        input: [['taskId', 'number'], ['skillId', 'number']]
      });
      this.addSender('submitTaskDeliverable', {
        input: [['taskId', 'number'], ['deliverableHash', 'ipfsHash']]
      });
      this.addSender('startNextRewardPayout', {
        input: [['token', 'address']]
      });
      this.addSender('waiveRewardPayouts', {
        input: [['numPayouts', 'number']]
      });
      this.addSender('submitTaskWorkRating', {
        input: [['taskId', 'number'], ['role', 'role'], ['ratingSecret', 'string']]
      });

      // Multisig Senders
      var makeExecuteTaskChange = function makeExecuteTaskChange(name, input) {
        var roles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        return _this2.addMultisigSender(name, {
          input: [['taskId', 'number']].concat((0, _toConsumableArray3.default)(input)),
          getRequiredSignees: function () {
            var _ref14 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4(_ref13) {
              var taskId = _ref13.taskId;
              var taskRoles;
              return _regenerator2.default.wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      _context4.next = 2;
                      return Promise.all(roles.map(function (role) {
                        return _this2.getTaskRole.call({ taskId: taskId, role: role });
                      }));

                    case 2:
                      taskRoles = _context4.sent;
                      return _context4.abrupt('return', taskRoles.map(function (_ref15) {
                        var address = _ref15.address;
                        return address;
                      }).filter(_colonyJsUtils.isValidAddress));

                    case 4:
                    case 'end':
                      return _context4.stop();
                  }
                }
              }, _callee4, _this2);
            }));

            function getRequiredSignees(_x4) {
              return _ref14.apply(this, arguments);
            }

            return getRequiredSignees;
          }(),
          multisigFunctionName: 'executeTaskChange',
          nonceFunctionName: 'getTaskChangeNonce',
          nonceInput: [['taskId', 'number']]
        });
      };
      makeExecuteTaskChange('setTaskBrief', [['specificationHash', 'ipfsHash']], [_constants.MANAGER_ROLE, _constants.WORKER_ROLE]);
      makeExecuteTaskChange('setTaskDueDate', [['dueDate', 'date']], [_constants.MANAGER_ROLE, _constants.WORKER_ROLE]);
      makeExecuteTaskChange('setTaskWorkerPayout', [['source', 'payableAddress'], ['amount', 'bigNumber']], [_constants.MANAGER_ROLE, _constants.WORKER_ROLE]);
      makeExecuteTaskChange('setTaskEvaluatorPayout', [['source', 'payableAddress'], ['amount', 'bigNumber']], [_constants.MANAGER_ROLE, _constants.EVALUATOR_ROLE]);
    }
  }]);
  return ColonyClient;
}(_colonyJsContractClient2.default);
// eslint-disable-next-line max-len


exports.default = ColonyClient;
//# sourceMappingURL=index.js.map