'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isInputEmpty = exports.areParamPairsEmpty = exports.isBoolean = undefined;

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

exports.validateValue = validateValue;
exports.validateParams = validateParams;

var _lodash = require('lodash.isplainobject');

var _lodash2 = _interopRequireDefault(_lodash);

var _colonyJsUtils = require('@colony/colony-js-utils');

var _paramTypes = require('./paramTypes');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defaultAssert = (0, _colonyJsUtils.makeAssert)('Parameter Validation');

var isBoolean = exports.isBoolean = function isBoolean(value) {
  return typeof value === 'boolean';
};

var areParamPairsEmpty = exports.areParamPairsEmpty = function areParamPairsEmpty(paramPairs) {
  return paramPairs == null || Array.isArray(paramPairs) && paramPairs.length === 0;
};

var isInputEmpty = exports.isInputEmpty = function isInputEmpty(input) {
  return input == null || (0, _lodash2.default)(input) && Object.getOwnPropertyNames(input).length === 0;
};

function validateValue(value, _ref) {
  var _ref2 = (0, _slicedToArray3.default)(_ref, 3),
      name = _ref2[0],
      type = _ref2[1],
      defaultValue = _ref2[2];

  var assertValid = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultAssert;

  var reason = void 0;
  var isValid = false;

  try {
    isValid = (0, _paramTypes.validateValueType)(typeof value !== 'undefined' ? value : defaultValue, type);
  } catch (error) {
    reason = error.message || error.toString();
  }

  return assertValid(Boolean(isValid), 'Parameter "' + name + '" expected a value of type "' + type + '"' + (reason ? ' (' + reason + ')' : ''));
}

/**
 * Given parameters (as an object with named parameters, but potentially any
 * kind of invalid input), validate each parameter against the expected type
 * for this method, throwing vaidation errors or returning true.
 */
function validateParams(params, spec) {
  var assertValid = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultAssert;

  if (areParamPairsEmpty(spec) && isInputEmpty(params)) {
    return true;
  }

  assertValid((0, _lodash2.default)(params), 'Expected parameters as an object');

  var inputValues = Object.assign({}, params);

  // Either the parameter name should exist in the inputValues,
  // or the parameter should have a default value.
  var missingParams = spec.filter(function (param) {
    return !(Object.hasOwnProperty.call(inputValues, param[0]) || param.length === 3);
  });

  assertValid(missingParams.length === 0, 'Missing parameters: "' + missingParams.map(function (_ref3) {
    var _ref4 = (0, _slicedToArray3.default)(_ref3, 1),
        name = _ref4[0];

    return name;
  }).join(', ') + '"');

  return spec.every(function (paramSpec) {
    return validateValue(inputValues[paramSpec[0]], paramSpec);
  });
}
//# sourceMappingURL=paramValidation.js.map