'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

exports.convertInputValues = convertInputValues;
exports.convertOutputValues = convertOutputValues;

var _paramTypes = require('./paramTypes');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Given input values for a contract method call, as well as their type
 * specifications, generate a list of parameters that contains the encoded
 * parameters.
 */
function convertInputValues(inputValues, valuesSpec) {
  return valuesSpec.map(function (_ref) {
    var _ref2 = (0, _slicedToArray3.default)(_ref, 3),
        paramName = _ref2[0],
        paramType = _ref2[1],
        defaultValue = _ref2[2];

    return (0, _paramTypes.convertInputValue)(Object.hasOwnProperty.call(inputValues, paramName) ? inputValues[paramName] : defaultValue, paramType);
  });
}

/**
 * Given output values of a contract method call or a contract event, as well as
 * their type specifications, generate an object that consists of the converted
 * values with their respective types.
 */

function convertOutputValues(outputValues, valuesSpec) {
  return valuesSpec && valuesSpec.length ? // $FlowFixMe
  valuesSpec.map(function (_ref3) {
    var _ref4 = (0, _slicedToArray3.default)(_ref3, 2),
        name = _ref4[0],
        type = _ref4[1];

    return [name, (0, _paramTypes.convertOutputValue)(outputValues[name], type)];
  }).reduce(function (acc, _ref5) {
    var _ref6 = (0, _slicedToArray3.default)(_ref5, 2),
        name = _ref6[0],
        value = _ref6[1];

    return Object.assign(acc, (0, _defineProperty3.default)({}, name, value));
  }, {}) : // $FlowFixMe
  outputValues;
}
//# sourceMappingURL=paramConversion.js.map