{"version":3,"sources":["../../src/classes/ContractEvent.js"],"names":["normalizeEventParams","spec","map","parameterName","parameterType","undefined","ContractEvent","eventName","client","argsDef","_wrappedHandlers","Map","assertValid","handlerFunction","get","wrappedHandlerFunction","constructor","wrapHandlerFunction","contract","addListener","set","removeListener","delete","args","parsedArgs"],"mappings":";;;;;;;;;;;;;;;;;;AAEA;;AACA;;;;AACA;;AACA;;;;AAOA,IAAMA,uBAAuB,SAAvBA,oBAAuB,CAACC,IAAD;AAAA,SAC3BA,KAAKC,GAAL,CAAS;AAAA;AAAA,QAAEC,aAAF;AAAA,QAAiBC,aAAjB;;AAAA,WAAoC,CAC3CD,aAD2C,EAE3CC,aAF2C,EAG3CC,SAH2C,CAApC;AAAA,GAAT,CAD2B;AAAA,CAA7B;;IAOqBC,a;;AAUnB;;;AANA;AAYA,gCAQG;AAAA,QAPDC,SAOC,SAPDA,SAOC;AAAA,QANDC,MAMC,SANDA,MAMC;AAAA,QALDC,OAKC,SALDA,OAKC;AAAA;;AACD,SAAKF,SAAL,GAAiBA,SAAjB;AACA,SAAKC,MAAL,GAAcA,MAAd;AACA,SAAKC,OAAL,GAAeT,qBAAqBS,OAArB,CAAf;;AAEA,SAAKC,gBAAL,GAAwB,IAAIC,GAAJ,EAAxB;AACA,SAAKC,WAAL,GAAmB,gEAA0CL,SAA1C,CAAnB;AACD;;AAED;;;;;;AApBA;;;AANA;;AANA;;;;;;;AAiDA;;;;;gCAKYM,e,EAAiD;AAC3D,UAAI,KAAKH,gBAAL,CAAsBI,GAAtB,CAA0BD,eAA1B,CAAJ,EAAgD;AAC9C;AACD;;AAED,UAAME,yBAAyB,KAAKC,WAAL,CAAiBC,mBAAjB,CAC7BJ,eAD6B,EAE7B,KAAKJ,OAFwB,EAG7B,KAAKG,WAHwB,CAA/B;;AAMA,WAAKJ,MAAL,CAAYU,QAAZ,CAAqBC,WAArB,CAAiC,KAAKZ,SAAtC,EAAiDQ,sBAAjD;AACA,WAAKL,gBAAL,CAAsBU,GAAtB,CAA0BP,eAA1B,EAA2CE,sBAA3C;AACD;;AAED;;;;;;;mCAIeF,e,EAAiD;AAC9D,UAAME,yBAAyB,KAAKL,gBAAL,CAAsBI,GAAtB,CAA0BD,eAA1B,CAA/B;;AAEA,UAAIE,sBAAJ,EAA4B;AAC1B,aAAKP,MAAL,CAAYU,QAAZ,CAAqBG,cAArB,CACE,KAAKd,SADP,EAEEQ,sBAFF;;AAKA,aAAKL,gBAAL,CAAsBY,MAAtB,CAA6BT,eAA7B;AACD;AACF;;;wCA/CCA,e,EACAJ,O,EACAG,W,EACe;AACf,aAAO,iBAAqB;AAAA,YAAlBW,IAAkB,SAAlBA,IAAkB;;AAC1B,YAAMC,aAAa,0CAAoBD,IAApB,EAA0Bd,OAA1B,CAAnB;AACA,6CAAee,UAAf,EAA2Bf,OAA3B,EAAoCG,WAApC;;AAEAC,wBAAgBW,UAAhB;AACD,OALD;AAMD;;;;;kBAhDkBlB,a","file":"ContractEvent.js","sourcesContent":["// @flow\nimport type { Event, EventCallback } from '@colony/colony-js-adapter';\nimport { makeAssert } from '@colony/colony-js-utils';\nimport ContractClient from '../classes/ContractClient';\nimport { convertOutputValues } from '../modules/paramConversion';\nimport { validateParams } from '../modules/paramValidation';\n\nimport type { Params, EventParams } from '../flowtypes';\n\ntype AssertionMethod = (assertion: boolean, reason: string) => any;\ntype TypedEventCallback<ParamTypes> = (args: ParamTypes) => void;\n\nconst normalizeEventParams = (spec: EventParams): Params =>\n  spec.map(([parameterName, parameterType]) => [\n    parameterName,\n    parameterType,\n    undefined,\n  ]);\n\nexport default class ContractEvent<ParamTypes: Object> {\n  // The event's name as defined in the contract.\n  eventName: string;\n\n  // The respective contract's ContractClient instance.\n  client: ContractClient;\n\n  // The type definitions of the event's arguments.\n  argsDef: Params;\n\n  // A store for the event handlers that got wrapped for type validation.\n  _wrappedHandlers: Map<EventCallback, EventCallback>;\n\n  // Throwing custom assertion messages.\n  assertValid: AssertionMethod;\n\n  constructor({\n    eventName,\n    client,\n    argsDef,\n  }: {\n    eventName: string,\n    client: ContractClient,\n    argsDef: EventParams,\n  }) {\n    this.eventName = eventName;\n    this.client = client;\n    this.argsDef = normalizeEventParams(argsDef);\n\n    this._wrappedHandlers = new Map();\n    this.assertValid = makeAssert(`Validation failed for event ${eventName}`);\n  }\n\n  /**\n   * In order to be able to parse and validate event parameters as expected,\n   * we use this static method to wrap event handlers before executing them.\n   */\n  static wrapHandlerFunction(\n    handlerFunction: TypedEventCallback<ParamTypes>,\n    argsDef: Params,\n    assertValid: AssertionMethod,\n  ): EventCallback {\n    return ({ args }: Event) => {\n      const parsedArgs = convertOutputValues(args, argsDef);\n      validateParams(parsedArgs, argsDef, assertValid);\n\n      handlerFunction(parsedArgs);\n    };\n  }\n\n  /**\n   * Given the contract this instance has been instantiated on, `addListener`\n   * adds a new event handler to the respective event that gets called once the\n   * event has been emitted by the contract.\n   */\n  addListener(handlerFunction: TypedEventCallback<ParamTypes>) {\n    if (this._wrappedHandlers.get(handlerFunction)) {\n      return;\n    }\n\n    const wrappedHandlerFunction = this.constructor.wrapHandlerFunction(\n      handlerFunction,\n      this.argsDef,\n      this.assertValid,\n    );\n\n    this.client.contract.addListener(this.eventName, wrappedHandlerFunction);\n    this._wrappedHandlers.set(handlerFunction, wrappedHandlerFunction);\n  }\n\n  /**\n   * If an event handler has been added for this event previously,\n   * `removeListener` removes it.\n   */\n  removeListener(handlerFunction: TypedEventCallback<ParamTypes>) {\n    const wrappedHandlerFunction = this._wrappedHandlers.get(handlerFunction);\n\n    if (wrappedHandlerFunction) {\n      this.client.contract.removeListener(\n        this.eventName,\n        wrappedHandlerFunction,\n      );\n\n      this._wrappedHandlers.delete(handlerFunction);\n    }\n  }\n}\n"]}