{"version":3,"sources":["../../src/classes/ContractMethodMultisigSender.js"],"names":["ContractMethodMultisigSender","client","eventHandlers","functionName","input","name","getRequiredSignees","multisigFunctionName","nonceFunctionName","nonceInput","output","_getRequiredSignees","args","op","refresh","inputValues","signees","Array","isArray","every","getValidatedArgs","call","response","nonce","toNumber","Number","isInteger","options","Error","_send","data","createTransactionData","_startOperation","payload","destinationAddress","contract","address","sourceAddress","value","json","parsed","JSON","parse","callArgs","transactionOptions","send"],"mappings":"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","file":"ContractMethodMultisigSender.js","sourcesContent":["/* @flow */\n\nimport assert from 'assert';\nimport { isBigNumber, isValidAddress } from '@colony/colony-js-utils';\nimport type { TransactionOptions } from '@colony/colony-js-adapter';\n\nimport ContractClient from './ContractClient';\nimport ContractMethodSender from './ContractMethodSender';\nimport MultisigOperation from './MultisigOperation';\n\nimport type {\n  ContractMethodMultisigSenderArgs,\n  GetRequiredSignees,\n  MultisigOperationConstructorArgs,\n  Params,\n  SendOptions,\n} from '../flowtypes';\n\nexport default class ContractMethodMultisigSender<\n  InputValues: { [outputValueName: string]: any },\n  OutputValues: { [outputValueName: string]: any },\n  IContractClient: ContractClient,\n> extends ContractMethodSender<InputValues, OutputValues, IContractClient> {\n  nonceFunctionName: string;\n  nonceInput: Params;\n  multisigFunctionName: string;\n  _getRequiredSignees: GetRequiredSignees;\n\n  /**\n   * {string} functionName - The contract function name to use for\n   * creating the transaction data\n   * nonceFunctionName - The contract function name to use for\n   * getting the transaction nonce value\n   * required in order to send the transaction\n   * getRequiredSignees - Async function that returns the addresses of\n   * the signers which will be required in order to send the transaction\n   * multisigFunctionName - The contract function name to use for\n   * sending the finalized transaction (with multisig support)\n   */\n  constructor({\n    client,\n    eventHandlers,\n    functionName,\n    input,\n    name,\n    getRequiredSignees,\n    multisigFunctionName,\n    nonceFunctionName,\n    nonceInput,\n    output,\n  }: ContractMethodMultisigSenderArgs<IContractClient>) {\n    super({ client, name, output, input, eventHandlers, functionName });\n    this._getRequiredSignees = getRequiredSignees;\n    this.multisigFunctionName = multisigFunctionName;\n    this.nonceFunctionName = nonceFunctionName;\n    this.nonceInput = nonceInput;\n  }\n\n  /**\n   * Given a payload and optional signers, start a new MultisigOperation and\n   * refresh it (in order to set the required signees/nonce/etc).\n   */\n  async _startOperation(args: MultisigOperationConstructorArgs<InputValues>) {\n    // Will throw an error if the payload, signers or nonce are deemed invalid.\n    const op = new MultisigOperation(this, args);\n\n    await op.refresh();\n    return op;\n  }\n\n  async getRequiredSignees(inputValues: InputValues): Promise<Array<string>> {\n    const signees = await this._getRequiredSignees(inputValues);\n    assert(\n      Array.isArray(signees) && signees.every(isValidAddress),\n      'Expected an array of signee addresses',\n    );\n    return signees;\n  }\n\n  async getNonce(inputValues: InputValues): Promise<number> {\n    const args = this.getValidatedArgs(inputValues, this.nonceInput);\n    const response = await this.client.call(this.nonceFunctionName, args);\n\n    const nonce = isBigNumber(response) ? response.toNumber() : response;\n    assert(\n      Number(nonce) === nonce && Number.isInteger(nonce),\n      'Nonce must be an integer',\n    );\n\n    return nonce;\n  }\n  // eslint-disable-next-line class-methods-use-this,no-unused-vars\n  async send(inputValues: InputValues, options: SendOptions) {\n    throw new Error(\n      'This Sender uses multi-signature transactions; call ' +\n        '`.startOperation()` to start a new `MultisigOperation`',\n    );\n  }\n\n  /**\n   * Given arguments and options for a multisig function, send a transaction.\n   */\n  async sendMultisig(args: Array<any>, options: SendOptions) {\n    return this._send(args, options);\n  }\n\n  /**\n   * Given input values for the target contract method, create transaction data,\n   * and pass the payload into a new MultisigOperation.\n   */\n  async startOperation(inputValues: InputValues) {\n    const args = this.getValidatedArgs(inputValues);\n    const data = this.client.createTransactionData(this.functionName, args);\n\n    return this._startOperation({\n      payload: {\n        data,\n        inputValues,\n        destinationAddress: this.client.contract.address,\n        sourceAddress: this.client.contract.address,\n        value: 0,\n      },\n    });\n  }\n\n  /**\n   * Given the state of an operation as JSON, restore a MultisigOperation.\n   */\n  async restoreOperation(json: string) {\n    let parsed = {};\n    try {\n      parsed = JSON.parse(json);\n    } catch (error) {\n      throw new Error('Unable to restore operation: could not parse JSON');\n    }\n    return this._startOperation(parsed);\n  }\n\n  /**\n   * Override the method from the parent class; use `multisigFunctionName`.\n   */\n  async _sendTransaction(\n    callArgs: Array<any>,\n    transactionOptions: TransactionOptions,\n  ) {\n    return this.client.send(\n      this.multisigFunctionName,\n      callArgs,\n      transactionOptions,\n    );\n  }\n}\n"]}