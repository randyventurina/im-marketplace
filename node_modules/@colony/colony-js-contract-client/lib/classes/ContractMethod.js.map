{"version":3,"sources":["../../src/classes/ContractMethod.js"],"names":["ContractMethod","client","functionName","name","input","output","assertValid","inputValues","params","args","length","convertInputValues","Object","getOwnPropertyNames","console","warn","callArgs","createTransactionData","callResult","values","concat","parsedResult","reduce","acc","index","assign","validate","_getMethodArgs"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAGA;;;;AACA;;AAEA;;;;AACA;;AAIA;;;;AAGA;;;IAGqBA,c;AAYnB,4BAM6C;AAAA,mFAAJ,EAAI;AAAA,QAL3CC,MAK2C,QAL3CA,MAK2C;AAAA,QAJ3CC,YAI2C,QAJ3CA,YAI2C;AAAA,QAH3CC,IAG2C,QAH3CA,IAG2C;AAAA,QAF3CC,KAE2C,QAF3CA,KAE2C;AAAA,QAD3CC,MAC2C,QAD3CA,MAC2C;;AAAA;;AAC3C,SAAKF,IAAL,GAAYA,IAAZ;AACA,SAAKF,MAAL,GAAcA,MAAd;AACA,SAAKG,KAAL,GAAaA,KAAb;AACA,SAAKF,YAAL,GAAoBA,YAApB;AACA,SAAKI,WAAL,GAAmB,0DAAoCH,IAApC,CAAnB;AACA,QAAIE,MAAJ,EAAY,KAAKA,MAAL,GAAcA,MAAd;AACb;;AAED;;;;;;;;mCAIeE,W,EAA2BC,M,EAA6B;AACrE,UAAIC,OAAO,EAAX;;AAEA,UAAIF,eAAe,IAAnB,EAAyB,OAAOE,IAAP;;AAEzB,UAAID,UAAUA,OAAOE,MAArB,EAA6B;AAC3BD,eAAO,KAAKE,kBAAL,CAAwBJ,WAAxB,EAAqCC,MAArC,CAAP;AACD,OAFD,MAEO,IACL,sBAAcD,WAAd,KACAK,OAAOC,mBAAP,CAA2BN,WAA3B,EAAwCG,MAFnC,EAGL;AACA;AACAI,gBAAQC,IAAR,CACE,sEACE,4BAFJ;AAID;AACD,aAAON,IAAP;AACD;;AAED;;;;;;;0CAIsBO,Q,EAAsB;AAC1C,aAAO,KAAKf,MAAL,CAAYgB,qBAAZ,CAAkC,KAAKf,YAAvC,EAAqDc,QAArD,CAAP;AACD;;AAED;;;;;;6BAGST,W,EAAgD;AAAA,UAA7BC,MAA6B,uEAAZ,KAAKJ,KAAO;;AACvD,aAAO,qCAAeG,WAAf,EAA4BC,MAA5B,EAAoC,KAAKF,WAAzC,CAAP;AACD;;AAED;;;;;;;;uCAMEC,W,EAEY;AAAA,UADZC,MACY,uEADK,KAAKJ,KACV;;AACZ,aAAO,yCAAmBG,WAAnB,EAAgCC,MAAhC,CAAP;AACD;;AAED;;;;;;;;wCAMEU,U;AACA;AACAX,e,EACc;AACd,UAAMY,SAAS,GAAGC,MAAH,CAAUF,UAAV,CAAf;;AAEA,UAAMG,eAAe,KAAKhB,MAAL,CAAYiB,MAAZ,CACnB,UAACC,GAAD,SAAcC,KAAd;AAAA;AAAA,YAAOrB,IAAP;;AAAA,eAAwBS,OAAOa,MAAP,CAAcF,GAAd,oCAAsBpB,IAAtB,EAA6BgB,OAAOK,KAAP,CAA7B,EAAxB;AAAA,OADmB,EAEnB,EAFmB,CAArB;;AAKA,aAAO,0CAAoBH,YAApB,EAAkC,KAAKhB,MAAvC,CAAP;AACD;;AAED;;;;;;qCAGiBE,W,EAAgD;AAAA,UAA7BC,MAA6B,uEAAZ,KAAKJ,KAAO;;AAC/D,WAAKsB,QAAL,CAAcnB,WAAd,EAA2BC,MAA3B;AACA,aAAO,KAAKmB,cAAL,CAAoBpB,WAApB,EAAiCC,MAAjC,CAAP;AACD;;;;AAxHH;;kBAgBqBR,c","file":"ContractMethod.js","sourcesContent":["/* @flow */\n/* eslint-disable no-underscore-dangle */\n\nimport isPlainObject from 'lodash.isplainobject';\nimport { makeAssert } from '@colony/colony-js-utils';\n\nimport ContractClient from './ContractClient';\nimport {\n  convertInputValues,\n  convertOutputValues,\n} from '../modules/paramConversion';\nimport { validateParams } from '../modules/paramValidation';\nimport type { ContractMethodArgs, Params } from '../flowtypes';\n\n/**\n * Abstract class for interacting with contract methods.\n */\nexport default class ContractMethod<\n  InputValues: { [inputValueName: string]: any },\n  OutputValues: { [outputValueName: string]: any },\n  IContractClient: ContractClient,\n> {\n  assertValid: Function;\n  client: IContractClient;\n  functionName: string;\n  input: Params;\n  name: string;\n  output: Params;\n\n  constructor({\n    client,\n    functionName,\n    name,\n    input,\n    output,\n  }: ContractMethodArgs<IContractClient> = {}) {\n    this.name = name;\n    this.client = client;\n    this.input = input;\n    this.functionName = functionName;\n    this.assertValid = makeAssert(`Validation failed for ${name}`);\n    if (output) this.output = output;\n  }\n\n  /**\n   * Given named input values, transform these with the expected parameters\n   * in order to get an array of arguments expected by the contract function.\n   */\n  _getMethodArgs(inputValues?: InputValues, params?: Params): Array<any> {\n    let args = [];\n\n    if (inputValues == null) return args;\n\n    if (params && params.length) {\n      args = this.convertInputValues(inputValues, params);\n    } else if (\n      isPlainObject(inputValues) &&\n      Object.getOwnPropertyNames(inputValues).length\n    ) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        'Warning: _getMethodArgs called with parameters for a method that ' +\n          'does not accept parameters',\n      );\n    }\n    return args;\n  }\n\n  /**\n   * Given arguments to call the contract method with, return\n   * transaction data as a hex string.\n   */\n  createTransactionData(callArgs: Array<any>) {\n    return this.client.createTransactionData(this.functionName, callArgs);\n  }\n\n  /**\n   * Given input values, validate them against the expected params\n   */\n  validate(inputValues?: any, params: Params = this.input) {\n    return validateParams(inputValues, params, this.assertValid);\n  }\n\n  /**\n   * Given input values, map them against the expected parameters,\n   * with the appropriate conversion for each type.\n   * Fall back to default values for each parameter.\n   */\n  convertInputValues(\n    inputValues: InputValues,\n    params: Params = this.input,\n  ): Array<any> {\n    return convertInputValues(inputValues, params);\n  }\n\n  /**\n   * Given the result of a contract method call, transform these with the\n   * expected output parameters in order to get named output values as the\n   * method's `OutputValues`.\n   */\n  convertOutputValues(\n    callResult: any,\n    // eslint-disable-next-line no-unused-vars\n    inputValues?: InputValues,\n  ): OutputValues {\n    const values = [].concat(callResult);\n\n    const parsedResult = this.output.reduce(\n      (acc, [name], index) => Object.assign(acc, { [name]: values[index] }),\n      {},\n    );\n\n    return convertOutputValues(parsedResult, this.output);\n  }\n\n  /**\n   * Given input values, validate them and return parsed method args.\n   */\n  getValidatedArgs(inputValues?: any, params: Params = this.input) {\n    this.validate(inputValues, params);\n    return this._getMethodArgs(inputValues, params);\n  }\n}\n"]}