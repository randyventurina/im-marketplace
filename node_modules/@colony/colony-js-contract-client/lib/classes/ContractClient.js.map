{"version":3,"sources":["../../src/classes/ContractClient.js"],"names":["ContractClient","console","warn","adapter","query","events","_query","Object","assign","constructor","defaultQuery","_contract","Error","getContract","initializeContractMethods","functionName","args","contract","callConstant","callEstimate","options","callTransaction","params","getEventData","createTransactionData","Method","name","def","Reflect","has","client","addMethod","Caller","Sender","MultisigSender","eventName","argsDef"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAUA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;IAQqBA,c;;;;;AAanB;AACA;;;AAPA;;AANA;wBAciD;AAC/C;AACD;;AAPD;;;AANA;;;;wBAciD;AAC/C;AACD;;;wBACgE;AAC/D;AACD;;;wBACwC;AACvC;AACD;;;wBAEgC;AAC/B;AACAC,cAAQC,IAAR,CACE,sDACE,4BAFJ;AAIA,aAAO,EAAP;AACD;;;AAED,gCAA+D;AAAA,QAAjDC,OAAiD,QAAjDA,OAAiD;AAAA,QAAxCC,KAAwC,QAAxCA,KAAwC;AAAA;AAAA,SA1B/DC,MA0B+D,GA1BtD,EA0BsD;;AAC7D,SAAKF,OAAL,GAAeA,OAAf;AACA,SAAKG,MAAL,GAAcC,OAAOC,MAAP,CAAc,EAAd,EAAkB,KAAKC,WAAL,CAAiBC,YAAnC,EAAiDN,KAAjD,CAAd;AACD;;;;;;;;;;qBASK,KAAKO,S;;;;;sBAAiB,IAAIC,KAAJ,CAAU,oCAAV,C;;;;uBAEH,KAAKT,OAAL,CAAaU,WAAb,CAAyB,KAAKP,MAA9B,C;;;AAAvB,qBAAKK,S;;AACL,qBAAKG,yBAAL;iDACO,I;;;;;;;;;;;;;;;;;AAGT;;;AAGA;;;;gDACkC,CAAE;;AAEpC;;;;;;;;6GAIWC,Y,EAAsBC,I;;;;;kDACxB,KAAKC,QAAL,CAAcC,YAAd,CAA2BH,YAA3B,EAAyCC,IAAzC,C;;;;;;;;;;;;;;;;;AAGT;;;;;;;;;6GAKeD,Y,EAAsBC,I;;;;;kDAC5B,KAAKC,QAAL,CAAcE,YAAd,CAA2BJ,YAA3B,EAAyCC,IAAzC,C;;;;;;;;;;;;;;;;;AAGT;;;;;;;;;6GAMED,Y,EACAC,I,EACAI,O;;;;;kDAEO,KAAKH,QAAL,CAAcI,eAAd,CAA8BN,YAA9B,EAA4CC,IAA5C,EAAkDI,OAAlD,C;;;;;;;;;;;;;;;;;;;6GAGUE,M;;;;;kDAKV,KAAKnB,OAAL,CAAaoB,YAAb,CAA0BD,MAA1B,C;;;;;;;;;;;;;;;;;;0CAGaP,Y,EAAsBC,I,EAA0B;AACpE,aAAO,KAAKC,QAAL,CAAcO,qBAAd,CAAoCT,YAApC,EAAkDC,IAAlD,CAAP;AACD;;;8BAGCS,M,EACAC,I,EACAC,G,EACM;AACN,UAAIC,QAAQC,GAAR,CAAY,IAAZ,EAAkBH,IAAlB,CAAJ,EACE,MAAM,IAAId,KAAJ,8BAAqCc,IAArC,sBAAN;;AAEFnB,aAAOC,MAAP,CAAc,IAAd,oCACGkB,IADH,EACU,IAAID,MAAJ,0BAAaC,UAAb,EAAmBX,cAAcW,IAAjC,EAAuCI,QAAQ,IAA/C,IAAwDH,GAAxD,EADV;AAGD;;;8BAESD,I,EAAcC,G,EAAmB;AACzC,WAAKI,SAAL,CAAe,KAAKtB,WAAL,CAAiBuB,MAAhC,EAAwCN,IAAxC,EAA8CC,GAA9C;AACD;;;8BAESD,I,EAAcC,G,EAAmB;AACzC,WAAKI,SAAL,CAAe,KAAKtB,WAAL,CAAiBwB,MAAhC,EAAwCP,IAAxC,EAA8CC,GAA9C;AACD;;;sCAEiBD,I,EAAcC,G,EAAmB;AACjD,WAAKI,SAAL,CAAe,KAAKtB,WAAL,CAAiByB,cAAhC,EAAgDR,IAAhD,EAAsDC,GAAtD;AACD;;AAED;;;;;;;6BAISQ,S,EAAmBC,O,EAA4B;AACtD,UAAIR,QAAQC,GAAR,CAAY,KAAKxB,MAAjB,EAAyB8B,SAAzB,CAAJ,EAAyC;AACvC,cAAM,IAAIvB,KAAJ,sBAA6BuB,SAA7B,sBAAN;AACD;;AAED5B,aAAOC,MAAP,CAAc,KAAKH,MAAnB,oCACG8B,SADH,EACe,4BAAkB;AAC7BA,4BAD6B;AAE7BL,gBAAQ,IAFqB;AAG7BM;AAH6B,OAAlB,CADf;AAOD;;;wBAvGc;AACb,UAAI,CAAC,KAAKzB,SAAV,EACE,MAAM,IAAIC,KAAJ,CAAU,wDAAV,CAAN;AACF,aAAO,KAAKD,SAAZ;AACD;;;;;kBA9CkBX,c","file":"ContractClient.js","sourcesContent":["/* @flow */\n\nimport type { Query } from '@colony/colony-js-contract-loader';\nimport type {\n  IAdapter,\n  IContract,\n  EventHandlers,\n  TransactionOptions,\n} from '@colony/colony-js-adapter';\n\nimport ContractEvent from './ContractEvent';\nimport ContractMethod from './ContractMethod';\nimport ContractMethodCaller from './ContractMethodCaller';\nimport ContractMethodSender from './ContractMethodSender';\nimport ContractMethodMultisigSender from './ContractMethodMultisigSender';\n\nimport type {\n  ContractMethodDef,\n  ContractClientConstructorArgs,\n  EventParams,\n} from '../flowtypes';\n\nexport default class ContractClient {\n  // The adapter used to communicate with the blockchain\n  adapter: IAdapter;\n\n  // The contract interface (as provided by the adapter)\n  _contract: IContract;\n\n  // The contract loading query the class was constructed with\n  _query: Query;\n\n  // The contract event subscription methods\n  events = {};\n\n  // Static getters used in lieu of named exports; this package only has\n  // one export.\n  static get Caller(): typeof ContractMethodCaller {\n    return ContractMethodCaller;\n  }\n  static get Sender(): typeof ContractMethodSender {\n    return ContractMethodSender;\n  }\n  static get MultisigSender(): typeof ContractMethodMultisigSender {\n    return ContractMethodMultisigSender;\n  }\n  static get Event(): typeof ContractEvent {\n    return ContractEvent;\n  }\n\n  static get defaultQuery(): Query {\n    // eslint-disable-next-line no-console\n    console.warn(\n      'No query defined; defaultQuery is designed to be ' +\n        'defined in a derived class',\n    );\n    return {};\n  }\n\n  constructor({ adapter, query }: ContractClientConstructorArgs) {\n    this.adapter = adapter;\n    this._query = Object.assign({}, this.constructor.defaultQuery, query);\n  }\n\n  get contract() {\n    if (!this._contract)\n      throw new Error('Contract not loaded; did you forget to call `.init()`?');\n    return this._contract;\n  }\n\n  async init() {\n    if (this._contract) throw new Error('ContractClient already initialized');\n\n    this._contract = await this.adapter.getContract(this._query);\n    this.initializeContractMethods();\n    return this;\n  }\n\n  /**\n   * Designed to be overridden in a derived class; called in the constructor.\n   */\n  // eslint-disable-next-line class-methods-use-this\n  initializeContractMethods(): void {}\n\n  /**\n   * Low-level method to call a named contract function with an array of\n   * arguments that have been properly validated for that function.\n   */\n  async call(functionName: string, args: Array<any>) {\n    return this.contract.callConstant(functionName, args);\n  }\n\n  /**\n   * Low-level method to estimate the gas cost of sending a transaction to\n   * call a contract function with an array of arguments that have been\n   * properly validated for that function.\n   */\n  async estimate(functionName: string, args: Array<any>) {\n    return this.contract.callEstimate(functionName, args);\n  }\n\n  /**\n   * Low-level method to send a transaction to a named contract function\n   * with an array of arguments that have been properly validated for that\n   * function, and optional transaction options.\n   */\n  async send(\n    functionName: string,\n    args: Array<any>,\n    options: TransactionOptions,\n  ) {\n    return this.contract.callTransaction(functionName, args, options);\n  }\n\n  async getEventData(params: {\n    events: EventHandlers,\n    timeoutMs: number,\n    transactionHash: string,\n  }) {\n    return this.adapter.getEventData(params);\n  }\n\n  createTransactionData(functionName: string, args: Array<any>): string {\n    return this.contract.createTransactionData(functionName, args);\n  }\n\n  addMethod(\n    Method: typeof ContractMethod.constructor,\n    name: string,\n    def: ContractMethodDef<*>,\n  ): void {\n    if (Reflect.has(this, name))\n      throw new Error(`A ContractMethod named \"${name}\" already exists`);\n\n    Object.assign(this, {\n      [name]: new Method({ name, functionName: name, client: this, ...def }),\n    });\n  }\n\n  addCaller(name: string, def: Object): void {\n    this.addMethod(this.constructor.Caller, name, def);\n  }\n\n  addSender(name: string, def: Object): void {\n    this.addMethod(this.constructor.Sender, name, def);\n  }\n\n  addMultisigSender(name: string, def: Object): void {\n    this.addMethod(this.constructor.MultisigSender, name, def);\n  }\n\n  /**\n   * Add event subscription functionality for a particular event of this\n   * contract to the given ContractClient instance.\n   */\n  addEvent(eventName: string, argsDef: EventParams): void {\n    if (Reflect.has(this.events, eventName)) {\n      throw new Error(`An event named \"${eventName}\" already exists`);\n    }\n\n    Object.assign(this.events, {\n      [eventName]: new ContractEvent({\n        eventName,\n        client: this,\n        argsDef,\n      }),\n    });\n  }\n}\n"]}