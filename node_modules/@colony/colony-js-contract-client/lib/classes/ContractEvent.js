'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _colonyJsUtils = require('@colony/colony-js-utils');

var _ContractClient = require('../classes/ContractClient');

var _ContractClient2 = _interopRequireDefault(_ContractClient);

var _paramConversion = require('../modules/paramConversion');

var _paramValidation = require('../modules/paramValidation');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var normalizeEventParams = function normalizeEventParams(spec) {
  return spec.map(function (_ref) {
    var _ref2 = (0, _slicedToArray3.default)(_ref, 2),
        parameterName = _ref2[0],
        parameterType = _ref2[1];

    return [parameterName, parameterType, undefined];
  });
};

var ContractEvent = function () {

  // A store for the event handlers that got wrapped for type validation.


  // The respective contract's ContractClient instance.
  function ContractEvent(_ref3) {
    var eventName = _ref3.eventName,
        client = _ref3.client,
        argsDef = _ref3.argsDef;
    (0, _classCallCheck3.default)(this, ContractEvent);

    this.eventName = eventName;
    this.client = client;
    this.argsDef = normalizeEventParams(argsDef);

    this._wrappedHandlers = new Map();
    this.assertValid = (0, _colonyJsUtils.makeAssert)('Validation failed for event ' + eventName);
  }

  /**
   * In order to be able to parse and validate event parameters as expected,
   * we use this static method to wrap event handlers before executing them.
   */


  // Throwing custom assertion messages.


  // The type definitions of the event's arguments.

  // The event's name as defined in the contract.


  (0, _createClass3.default)(ContractEvent, [{
    key: 'addListener',


    /**
     * Given the contract this instance has been instantiated on, `addListener`
     * adds a new event handler to the respective event that gets called once the
     * event has been emitted by the contract.
     */
    value: function addListener(handlerFunction) {
      if (this._wrappedHandlers.get(handlerFunction)) {
        return;
      }

      var wrappedHandlerFunction = this.constructor.wrapHandlerFunction(handlerFunction, this.argsDef, this.assertValid);

      this.client.contract.addListener(this.eventName, wrappedHandlerFunction);
      this._wrappedHandlers.set(handlerFunction, wrappedHandlerFunction);
    }

    /**
     * If an event handler has been added for this event previously,
     * `removeListener` removes it.
     */

  }, {
    key: 'removeListener',
    value: function removeListener(handlerFunction) {
      var wrappedHandlerFunction = this._wrappedHandlers.get(handlerFunction);

      if (wrappedHandlerFunction) {
        this.client.contract.removeListener(this.eventName, wrappedHandlerFunction);

        this._wrappedHandlers.delete(handlerFunction);
      }
    }
  }], [{
    key: 'wrapHandlerFunction',
    value: function wrapHandlerFunction(handlerFunction, argsDef, assertValid) {
      return function (_ref4) {
        var args = _ref4.args;

        var parsedArgs = (0, _paramConversion.convertOutputValues)(args, argsDef);
        (0, _paramValidation.validateParams)(parsedArgs, argsDef, assertValid);

        handlerFunction(parsedArgs);
      };
    }
  }]);
  return ContractEvent;
}();

exports.default = ContractEvent;
//# sourceMappingURL=ContractEvent.js.map