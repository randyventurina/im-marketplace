'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _lodash = require('lodash.isplainobject');

var _lodash2 = _interopRequireDefault(_lodash);

var _colonyJsUtils = require('@colony/colony-js-utils');

var _ContractClient = require('./ContractClient');

var _ContractClient2 = _interopRequireDefault(_ContractClient);

var _paramConversion = require('../modules/paramConversion');

var _paramValidation = require('../modules/paramValidation');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Abstract class for interacting with contract methods.
 */
var ContractMethod = function () {
  function ContractMethod() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        client = _ref.client,
        functionName = _ref.functionName,
        name = _ref.name,
        input = _ref.input,
        output = _ref.output;

    (0, _classCallCheck3.default)(this, ContractMethod);

    this.name = name;
    this.client = client;
    this.input = input;
    this.functionName = functionName;
    this.assertValid = (0, _colonyJsUtils.makeAssert)('Validation failed for ' + name);
    if (output) this.output = output;
  }

  /**
   * Given named input values, transform these with the expected parameters
   * in order to get an array of arguments expected by the contract function.
   */


  (0, _createClass3.default)(ContractMethod, [{
    key: '_getMethodArgs',
    value: function _getMethodArgs(inputValues, params) {
      var args = [];

      if (inputValues == null) return args;

      if (params && params.length) {
        args = this.convertInputValues(inputValues, params);
      } else if ((0, _lodash2.default)(inputValues) && Object.getOwnPropertyNames(inputValues).length) {
        // eslint-disable-next-line no-console
        console.warn('Warning: _getMethodArgs called with parameters for a method that ' + 'does not accept parameters');
      }
      return args;
    }

    /**
     * Given arguments to call the contract method with, return
     * transaction data as a hex string.
     */

  }, {
    key: 'createTransactionData',
    value: function createTransactionData(callArgs) {
      return this.client.createTransactionData(this.functionName, callArgs);
    }

    /**
     * Given input values, validate them against the expected params
     */

  }, {
    key: 'validate',
    value: function validate(inputValues) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.input;

      return (0, _paramValidation.validateParams)(inputValues, params, this.assertValid);
    }

    /**
     * Given input values, map them against the expected parameters,
     * with the appropriate conversion for each type.
     * Fall back to default values for each parameter.
     */

  }, {
    key: 'convertInputValues',
    value: function convertInputValues(inputValues) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.input;

      return (0, _paramConversion.convertInputValues)(inputValues, params);
    }

    /**
     * Given the result of a contract method call, transform these with the
     * expected output parameters in order to get named output values as the
     * method's `OutputValues`.
     */

  }, {
    key: 'convertOutputValues',
    value: function convertOutputValues(callResult,
    // eslint-disable-next-line no-unused-vars
    inputValues) {
      var values = [].concat(callResult);

      var parsedResult = this.output.reduce(function (acc, _ref2, index) {
        var _ref3 = (0, _slicedToArray3.default)(_ref2, 1),
            name = _ref3[0];

        return Object.assign(acc, (0, _defineProperty3.default)({}, name, values[index]));
      }, {});

      return (0, _paramConversion.convertOutputValues)(parsedResult, this.output);
    }

    /**
     * Given input values, validate them and return parsed method args.
     */

  }, {
    key: 'getValidatedArgs',
    value: function getValidatedArgs(inputValues) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.input;

      this.validate(inputValues, params);
      return this._getMethodArgs(inputValues, params);
    }
  }]);
  return ContractMethod;
}();
/* eslint-disable no-underscore-dangle */

exports.default = ContractMethod;
//# sourceMappingURL=ContractMethod.js.map