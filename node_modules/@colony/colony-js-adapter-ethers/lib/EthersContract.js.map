{"version":3,"sources":["../src/EthersContract.js"],"names":["EthersContract","address","abi","wallet","_listeners","_initialiseEvents","functionName","args","fn","functions","TypeError","estimate","options","name","interfaceFn","interface","data","eventName","callback","transactionHash","push","handlerIndex","findIndex","eventHandler","splice","Object","getOwnPropertyNames","events","forEach","self","eventDispatcher","_dispatchEvent","event","eventHandlers","filter","removeListener","Contract"],"mappings":"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","file":"EthersContract.js","sourcesContent":["/* @flow */\n\nimport ethers from 'ethers';\n\nimport type {\n  Event,\n  EventCallback,\n  IContract,\n  IWallet,\n  TransactionOptions,\n} from '@colony/colony-js-adapter';\n\nclass EthersContract extends ethers.Contract implements IContract {\n  // A map of contract event names to callbacks\n  _listeners: Array<{\n    eventName: string,\n    callback: EventCallback,\n    transactionHash?: string,\n  }>;\n\n  /**\n   * EthersContract constructor\n   * Extends `ethers.Contract` with event handling that allows us to\n   * wait for event data and return it as the adapter interface specifies\n   */\n  constructor(address: string, abi: Array<any>, wallet: IWallet) {\n    super(address, abi, wallet);\n    this._listeners = [];\n    this._initialiseEvents();\n  }\n\n  /**\n   * Given a function name and an array of arguments, apply the arguments and\n   * return the resulting value/s.\n   */\n  async callConstant(functionName: string, args: Array<any>) {\n    const fn = this.functions[functionName];\n    if (typeof fn !== 'function')\n      throw new TypeError(`Function ${functionName} not found on contract`);\n    return fn(...args);\n  }\n\n  /**\n   * Given a function name and an array of arguments, apply the arguments and\n   * return the resulting gas cost estimate as a BigNumber\n   */\n  async callEstimate(functionName: string, args: Array<any>) {\n    const fn = this.estimate[functionName];\n    if (typeof fn !== 'function')\n      throw new TypeError(\n        `Estimation function ${functionName} not found on contract`,\n      );\n    return fn(...args);\n  }\n\n  /**\n   * Given a function name, an array of arguments and optional transaction\n   * options, apply the arguments and return the sent transaction\n   */\n  async callTransaction(\n    functionName: string,\n    args: Array<any>,\n    options: TransactionOptions,\n  ) {\n    const fn = this.functions[functionName];\n    if (typeof fn !== 'function')\n      throw new TypeError(`Function ${functionName} not found on contract`);\n    return fn(...args, options);\n  }\n\n  /**\n   * Given the name of an interface function, and an array of arguments\n   * that will be accepted byt that function, get the data from the interface\n   * by applying the arguments to it.\n   */\n  createTransactionData(name: string, args: Array<any>): string {\n    const interfaceFn = this.interface.functions[name];\n    if (typeof interfaceFn !== 'function')\n      throw new TypeError(`Function ${name} not found on contract interface`);\n    const { data } = interfaceFn(...args);\n    return data;\n  }\n\n  addListener(\n    eventName: string,\n    callback: EventCallback,\n    transactionHash?: string,\n  ) {\n    this._listeners.push({\n      eventName,\n      callback,\n      transactionHash,\n    });\n  }\n  removeListener(\n    eventName: string,\n    callback: Function,\n    transactionHash?: string,\n  ) {\n    const handlerIndex = this._listeners.findIndex(\n      eventHandler =>\n        eventName === eventHandler.eventName &&\n        callback === eventHandler.callback &&\n        (!transactionHash || transactionHash === eventHandler.transactionHash),\n    );\n\n    if (handlerIndex > -1) {\n      this._listeners.splice(handlerIndex, 1);\n    }\n  }\n  _initialiseEvents() {\n    Object.getOwnPropertyNames(this.events).forEach(eventName => {\n      const self = this;\n      this.events[eventName] = function eventDispatcher() {\n        self._dispatchEvent(this); // eslint-disable-line no-underscore-dangle\n      };\n    });\n  }\n  _dispatchEvent(event: Event) {\n    const eventHandlers = this._listeners.filter(\n      ({ eventName, transactionHash }) =>\n        eventName === event.event &&\n        (!transactionHash || transactionHash === event.transactionHash),\n    );\n\n    eventHandlers.forEach(eventHandler => {\n      if (eventHandler.transactionHash) {\n        this.removeListener(\n          event.event,\n          eventHandler.callback,\n          event.transactionHash,\n        );\n      }\n\n      eventHandler.callback(event);\n    });\n  }\n}\n\nexport default EthersContract;\n"]}